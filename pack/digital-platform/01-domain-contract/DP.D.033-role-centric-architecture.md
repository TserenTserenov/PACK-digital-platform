---
id: DP.D.033
name: "Role-Centric Architecture (Ролецентричная архитектура)"
type: distinction
status: active
summary: "Роль описывается независимо от исполнителя. Исполнитель выбирается и подготавливается отдельно. Роль = маска, которую надевает система (сама — если агент, или по воле другого агента — если инструмент). Одно имя (например, 'Синхронизатор') может обозначать и роль, и систему-исполнителя — это разные ракурсы, не тождество."
created: 2026-02-20
edition: "2026-02"
source: "Архитектурное решение 20 фев 2026. ArchGate: role-centric 50/60 vs system-centric 41/60"
trust:
  F: 4
  G: domain
  R: 0.85
related:
  extends: [DP.AGENT.001, DP.D.023]
  uses: [DP.SOTA.001]
  fpf: [A.2, A.3, A.13, A.15]
---

# Role-Centric Architecture (Ролецентричная архитектура)

## 1. Различение

| Подход | Фокус | Вопрос | Проблема |
|--------|-------|--------|----------|
| **System-Centric** (было) | Система → что умеет | «Что делает Синхронизатор?» | Роль склеена с исполнителем. Смена исполнителя = переписать всё |
| **Role-Centric** (решение) | Роль → кто исполняет | «Кто играет роль Синхронизатора?» | — |

**Тесты:**
- Можно ли описать функцию без упоминания конкретной системы? Да → роль. Нет → системная привязка.
- Если завтра исполнитель сменится (скрипт → LLM, или LLM → человек) — нужно ли переписывать описание? При role-centric — нет.

## 2. Онтологические основания (FPF)

### 2.1. Роль — универсальный механизм (FPF A.2)

**U.RoleAssignment** применяется к любой U.System — и к агентам (Grade 2+), и к инструментам (Grade 0-1), и к эпистемам. Роль — не свойство агента, а отношение между системой и её надсистемой (Suprasystem).

Нотация FPF: `Holder#Role:Context@Window`

| Поле FPF | Описание | Пример |
|----------|----------|--------|
| **Holder** | Система-исполнитель | synchronizer/scripts/*.sh |
| **Role** | Функция в надсистеме | Синхронизатор |
| **Context** | Ограниченный контекст (BC) | Платформа DP |
| **Window** | Временное окно активности | 24/7, launchd schedule |

### 2.2. Агентские vs функциональные роли (FPF A.13)

| Тип роли | Кто может играть | Min Grade | Пример |
|----------|------------------|-----------|--------|
| **Функциональная** (A.2) | Любая система | 0 | Синхронизатор, Шаблонизатор |
| **Агентская** (A.13) | Только агенты | 2 | Стратег, Консультант |

Агентская роль — подвид функциональной. Различие: агентская требует выбора КАК действовать (автономия). Функциональная — только исполнение.

### 2.3. Система в Системной Триаде (FPF A.3)

Роль существует в контексте надсистемы (X1.Suprasystem). Каждая роль имеет:
- **Надсистему** — где роль определена
- **Обязательства** (obligations) — что роль ДОЛЖНА делать
- **Ожидания** (expectations) — что другие роли ждут от неё

### 2.4. Роль ≠ Система

Одно имя может обозначать и роль, и систему (как «молоток» — и роль предмета для забивания, и конкретный физический объект). Это разные ракурсы:

| Ракурс | Вопрос | Ответ для «Синхронизатор» |
|--------|--------|--------------------------|
| **Роль** | Что должно делаться? | Обеспечивать согласованность view ↔ model |
| **Система** | Чем это делается? | Набор bash-скриптов + launchd + Claude (для Grade 2+ сценариев) |

## 3. Шаблон описания роли (Role Description Template)

```yaml
# === Role Description (FPF A.2 U.RoleAssignment + A.13) ===
# Notation: Holder#Role:Context@Window

name: "<Название роли>"
type: functional | agential           # A.2 vs A.13
suprasystem: "<Надсистема>"           # X1.Suprasystem (A.3)
context: "<Ограниченный контекст>"    # U.BoundedContext

# --- Обязательства и ожидания ---

obligations:                          # Что роль ДОЛЖНА делать
  - "<обязательство 1>"
  - "<обязательство 2>"

expectations:                         # Что другие роли ждут
  - from: "<Другая роль>"
    expects: "<ожидание>"

# --- Методы ---

methods:                              # КАК роль выполняет обязательства
  - name: "<Метод>"
    description: "<описание>"

# --- Входы (получает от других ролей) ---

inputs:                               # ЧТО роль получает и ОТ КОГО
  - input: "<Рабочий продукт>"
    source_role: "<Роль-источник>"
    data: "<Какие данные содержит>"
    trigger: "<Когда/при каком событии>"

# --- Рабочие продукты ---

work_products:                        # ЧТО роль создаёт и КОМУ передаёт
  - product: "<Рабочий продукт>"
    recipient: "<Получатель (роль или система)>"
    trigger: "<Когда создаётся>"

# --- Сценарии ---

scenarios:                            # Конкретные ситуации исполнения
  - name: "<Сценарий>"
    trigger: "<Что запускает>"
    min_agency_grade: 0-4             # Минимальный Grade для исполнения
    method: "<Метод из methods>"
    inputs: [<входы>]
    work_product: "<Продукт из work_products>"

# --- Исполнение ---

current_holders:                      # Кто СЕЙЧАС играет эту роль
  - holder: "<Система или агент>"
    grade: 0-4
    covers_scenarios: [<какие сценарии>]

# --- Связи ---

failure_modes: [<FM IDs>]             # Что может сломаться

related_roles:                        # Взаимодействие с другими ролями
  - role: "<Роль>"
    interaction: "<Как взаимодействуют>"
```

## 4. Подготовка исполнителя (Executor Preparation)

Когда роль описана, нужно выбрать и подготовить исполнителя:

| Способ подготовки | Для кого | Grade | Пример |
|-------------------|----------|-------|--------|
| **Изготовить** (manufacture) | Физический объект | 0 | Сервер, оборудование |
| **Спрограммировать** (program) | Скрипт, пайплайн | 0-1 | bash-скрипт, cron job |
| **Задать промпт** (prompt) | LLM | 2-3 | Промпт для Claude |
| **Обучить** (train) | Человек | 3-4 | Тренинг, менторинг |

Один исполнитель может играть несколько ролей. Одну роль могут играть несколько исполнителей (разные сценарии — разные Grade).

## 5. ArchGate сравнение

| Характеристика | Role-Centric | System-Centric |
|----------------|:---:|:---:|
| **Эволюционируемость** | 9 | 6 |
| **Масштабируемость** | 8 | 7 |
| **Обучаемость** | 8 | 7 |
| **Генеративность** | 9 | 6 |
| **Скорость** | 7 | 8 |
| **Современность** | 9 | 7 |
| **Итого** | **50** | **41** |

Ключевые преимущества role-centric:
- **Э+3:** Новый исполнитель = новый holder, роль не меняется
- **Г+3:** Шаблон экзокортекса получает каталог ролей, а не жёстко привязанных систем
- **С+2:** DDD Strategic + Context Engineering + FPF A.2 = SOTA-подход

## 6. Миграция System-Centric → Role-Centric

### Что меняется

| Было (system-centric) | Стало (role-centric) |
|------------------------|----------------------|
| system.yaml описывает систему | system.yaml ссылается на роли, которые система играет |
| DP.AGENT.001 §3: таблица систем → роли | DP.AGENT.001 §3: каталог ролей → исполнители |
| Промпт: «Ты — Claude в роли X» | Промпт: «Роль: X (DP.D.033 template). Исполнитель: Claude» |
| «Синхронизатор делает X» | «Роль Синхронизатора: X. Текущий исполнитель: скрипты + Claude» |

### Что НЕ меняется

- Файловая структура DS-ai-systems/ (папки = системы-исполнители)
- Grade оценки (применяются к исполнителям)
- Процессы (описываются в сценариях ролей)
